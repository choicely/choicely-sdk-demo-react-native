buildscript {
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

plugins {
    id "com.android.application"
    id 'org.jetbrains.kotlin.android'
    id "com.facebook.react"
}
apply from: "../../node_modules/react-native-vector-icons/fonts.gradle"

ext {
    REACT_NATIVE_NODE_MODULES_DIR = file("$rootDir/../node_modules/react-native").canonicalPath
    REACT_NATIVE_WORKLETS_NODE_MODULES_DIR = file("$rootDir/../node_modules/react-native-worklets").canonicalPath
}
react {
    nodeExecutableAndArgs.set([gradle.ext.nodeBinary])
    jsRootDir.set(file("../../rn"))
    bundleConfig.set(file("../../rn/metro.config.js"))
    entryFile.set(file("../../rn/src/index.js"))
    // Needed to enable Autolinking - https://github.com/react-native-community/cli/blob/master/docs/autolinking.md
    autolinkLibrariesWithApp()
}
android {
    namespace 'com.choicely.sdk.rn'
    compileSdk = (rootProject.ext.compileSdkVersion as Integer)
    defaultConfig {
        applicationId namespace
        targetSdk = compileSdk
        minSdk = (rootProject.ext.minSdkVersion as Integer)
        buildToolsVersion = rootProject.ext.buildToolsVersion
        versionCode 1
        versionName "1.0"
        ndk {
            abiFilters = rootProject.ext.reactNativeArchitectures.split(",").collect { it.trim() }
            // abiFilters "x86", "x86_64", "armeabi-v7a", "arm64-v8a"
        }
        def appName = rootProject.ext.has('choicelyAppName') ? rootProject.ext.choicelyAppName : null
        if (appName?.toString()?.trim()) {
            resValue "string", "app_name", appName.toString()
        }
        def appKey = rootProject.ext.has('choicelyAppKey') ? rootProject.ext.choicelyAppKey : null
        if (appKey?.toString()?.trim()) {
            resValue "string", "choicely_app_key", appKey.toString()
        }
        manifestPlaceholders = [extractNativeLibs: "false"]
    }
    signingConfigs {
        debug {
            v2SigningEnabled true
            def ks = rootProject.ext.has('apkKeyStore') ? rootProject.ext.apkKeyStore : null
            storeFile ks != null ? file("../../${ks}") : null
            storePassword rootProject.ext.has('apkStorePass') ? rootProject.ext.apkStorePass : null
            keyAlias rootProject.ext.has('apkKeyAlias') ? rootProject.ext.apkKeyAlias : null
            keyPassword rootProject.ext.has('apkKeyPass') ? rootProject.ext.apkKeyPass : null
        }
    }
    buildTypes {
        release {
            debuggable false
            jniDebuggable false
            minifyEnabled true
            shrinkResources true
            crunchPngs true
            buildConfigField "boolean", "USE_METRO", "false"
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            ndk { debugSymbolLevel 'none' }
        }
        debug {
            signingConfig signingConfigs.debug
            debuggable true
            jniDebuggable true
            minifyEnabled false
            shrinkResources false
            crunchPngs false
            applicationIdSuffix ".debug"
            versionNameSuffix "-debug"
            buildConfigField "boolean", "USE_METRO", "true"
        }
        debugDist {
            initWith(buildTypes.debug)
            debuggable false
            jniDebuggable false
            minifyEnabled true
            shrinkResources true
            crunchPngs true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            matchingFallbacks = ['debug', 'debugOptimized', 'release']
            ndk { debugSymbolLevel 'none' }
            manifestPlaceholders.extractNativeLibs = "true"
        }
        offline {
            initWith(buildTypes.debug)
            matchingFallbacks = ['debug', 'debugOptimized', 'release']
            buildConfigField "boolean", "USE_METRO", "false"
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    buildFeatures {
        viewBinding true
    }
    kotlin {
        jvmToolchain(17)
    }
    kotlinOptions {
        jvmTarget = '17'
    }
    lint {
        checkReleaseBuilds = false
    }
}
androidComponents {
    onVariants(selector().withBuildType("debugDist")) { variant ->
        variant.packaging.jniLibs.useLegacyPackaging.set(true)
    }
}
dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    implementation 'androidx.core:core-ktx:1.17.0'
    implementation "com.facebook.react:react-android:0.82.0"
    implementation "com.facebook.react:hermes-android:0.82.0"

    implementation "com.choicely.sdk:android-core:1.1.1-SNAPSHOT"

    implementation "androidx.preference:preference-ktx:1.2.1"
}
afterEvaluate {
    tasks.matching { it.name.startsWith("externalNativeBuildClean") }.configureEach {
        enabled = false
    }
    android.applicationVariants.configureEach { variant ->
        if (variant.buildType.name in ["release", "offline", "debugDist"]) {
            def vName = variant.name.capitalize()
            tasks.named("merge${vName}Assets").configure {
                dependsOn("createBundle${vName}JsAndAssets")
            }
        }
    }
}
// Reverses Metro (and optional extra ports) for ALL connected devices/emulators
tasks.register("adbReverseMetro") {
    doLast {
        def adb = android.adbExecutable
        def metroPort = rootProject.ext.reactNativeDevServerPort
        // add more ports if you want:
        def ports = [metroPort].unique()
        def buf = new ByteArrayOutputStream()
        exec {
            commandLine adb, "devices"
            standardOutput = buf
            ignoreExitValue true
        }
        def lines = buf.toString("UTF-8").readLines()
        def serials = lines.findAll {
            it && !it.startsWith("List of devices")
                    && !it.contains("offline") && !it.contains("unauthorized")
                    && it.split().size() >= 2 && it.split()[1].startsWith("device")
        }
                .collect { it.split()[0] }
        if (serials.isEmpty()) {
            println "[dev] no connected devices/emulators"
            return
        }
        serials.each { s ->
            ports.each { p ->
                println "[dev] adb -s ${s} reverse tcp:${p} -> tcp:${p}"
                exec {
                    commandLine adb, "-s", s, "reverse", "tcp:${p}", "tcp:${p}"
                    ignoreExitValue true
                }
            }
        }
    }
}
tasks.register("prepareDevRuntime") { t ->
    t.dependsOn("adbReverseMetro")
}
def assembleRx = ~/(?i).*assemble.*(Debug|DebugDist|DebugOptimized)$/
tasks.configureEach { t ->
    if (t.name ==~ assembleRx) {
        t.dependsOn("prepareDevRuntime")
    }
}
